<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Dodge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #70c5ce;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            background-color: #70c5ce;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            max-width: 100%;
            max-height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .btn {
            pointer-events: auto;
            background: #e67e22;
            border: none;
            padding: 12px 24px;
            font-size: 1.25rem;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s;
            box-shadow: 0 4px 0 #d35400;
            margin-top: 15px;
        }
        .btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        .hidden { display: none; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-overlay">
        <!-- Start Screen -->
        <div id="start-screen" class="flex flex-col items-center">
            <h1 class="text-6xl font-bold mb-4 text-center">FLAPPY DODGE</h1>
            <p class="text-xl mb-4">Select Difficulty to Play</p>
            <div class="flex gap-4">
                <button class="btn !bg-blue-500 !shadow-blue-700" onclick="startGame('easy')">EASY</button>
                <button class="btn !bg-red-600 !shadow-red-800" onclick="startGame('hard')">HARD</button>
            </div>
            <p class="mt-4 text-sm opacity-80">Watch out for red fireballs!</p>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden flex flex-col items-center">
            <h2 class="text-5xl font-bold mb-2">GAME OVER</h2>
            <p id="final-score" class="text-2xl">Score: 0</p>
            <p id="best-score" class="text-xl">Best: 0</p>
            <button class="btn" onclick="showStartScreen()">MENU</button>
        </div>

        <!-- In-game Score -->
        <div id="score-display" class="hidden absolute top-10 text-6xl font-bold">0</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const scoreDisplay = document.getElementById('score-display');
    const finalScoreTxt = document.getElementById('final-score');
    const bestScoreTxt = document.getElementById('best-score');

    // Game constants
    const GRAVITY = 0.25;
    const JUMP = -4.6;
    const PIPE_SPEED = 2.5;
    const BIRD_SIZE = 34;
    
    // Dynamic difficulty variables
    let currentPipeGap = 210; 
    let currentSpawnRate = 100;
    let obstacleSpawnRate = 150;

    // Game state
    let bird, pipes, obstacles, frameCount, score, highScore, gameState;

    function resizeCanvas() {
        const aspect = 9 / 16;
        let h = window.innerHeight;
        let w = h * aspect;
        
        if (w > window.innerWidth) {
            w = window.innerWidth;
            h = w / aspect;
        }

        canvas.width = w;
        canvas.height = h;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    highScore = 0;
    gameState = 'START';

    class Bird {
        constructor() {
            this.x = canvas.width * 0.2;
            this.y = canvas.height / 2;
            this.velocity = 0;
            this.width = BIRD_SIZE;
            this.height = BIRD_SIZE * 0.8;
            this.rotation = 0;
        }

        update() {
            this.velocity += GRAVITY;
            this.y += this.velocity;
            this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity / 10)));

            if (this.y + this.height > canvas.height - 20) {
                this.y = canvas.height - 20 - this.height;
                endGame();
            }
            if (this.y < 0) {
                this.y = 0;
                this.velocity = 0;
            }
        }

        jump() {
            this.velocity = JUMP;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.rotation);
            
            // Body
            ctx.fillStyle = "#f1c40f";
            ctx.beginPath();
            ctx.ellipse(0, 0, this.width/2, this.height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Wing
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.ellipse(-10, 2, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Eye
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(8, -4, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(10, -4, 2, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = "#e67e22";
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(22, 2);
            ctx.lineTo(12, 6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }
    }

    class Obstacle {
        constructor() {
            this.radius = 8;
            this.x = canvas.width + 50;
            this.y = Math.random() * (canvas.height - 100) + 50;
            this.speed = PIPE_SPEED * 1.8;
        }

        update() {
            this.x -= this.speed;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#ff4d4d";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Trail effect
            ctx.beginPath();
            ctx.moveTo(this.x + 5, this.y);
            ctx.lineTo(this.x + 25, this.y - 3);
            ctx.lineTo(this.x + 20, this.y);
            ctx.lineTo(this.x + 25, this.y + 3);
            ctx.closePath();
            ctx.fillStyle = "rgba(255, 77, 77, 0.4)";
            ctx.fill();
        }

        collidesWith(bird) {
            const dx = this.x - (bird.x + bird.width / 2);
            const dy = this.y - (bird.y + bird.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (this.radius + bird.width / 2.5);
        }
    }

    class Pipe {
        constructor(prevTopHeight = null) {
            this.width = 65;
            
            const minHeight = 80;
            const maxHeight = canvas.height - currentPipeGap - 100;
            
            if (prevTopHeight !== null) {
                const maxStep = 160; 
                let start = Math.max(minHeight, prevTopHeight - maxStep);
                let end = Math.min(maxHeight, prevTopHeight + maxStep);
                this.topHeight = Math.random() * (end - start) + start;
            } else {
                this.topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
            }

            this.bottomY = this.topHeight + currentPipeGap;
            this.x = canvas.width;
            this.passed = false;
        }

        update() {
            this.x -= PIPE_SPEED;
        }

        draw() {
            ctx.fillStyle = "#2ecc71";
            ctx.strokeStyle = "#27ae60";
            ctx.lineWidth = 4;

            // Top Pipe
            ctx.fillRect(this.x, 0, this.width, this.topHeight);
            ctx.strokeRect(this.x, 0, this.width, this.topHeight);
            ctx.fillRect(this.x - 5, this.topHeight - 20, this.width + 10, 20);
            ctx.strokeRect(this.x - 5, this.topHeight - 20, this.width + 10, 20);

            // Bottom Pipe
            ctx.fillRect(this.x, this.bottomY, this.width, canvas.height - this.bottomY);
            ctx.strokeRect(this.x, this.bottomY, this.width, canvas.height - this.bottomY);
            ctx.fillRect(this.x - 5, this.bottomY, this.width + 10, 20);
            ctx.strokeRect(this.x - 5, this.bottomY, this.width + 10, 20);
        }

        collidesWith(bird) {
            const b = {
                left: bird.x + 6,
                right: bird.x + bird.width - 6,
                top: bird.y + 6,
                bottom: bird.y + bird.height - 6
            };

            if (b.right > this.x && b.left < this.x + this.width) {
                if (b.top < this.topHeight || b.bottom > this.bottomY) {
                    return true;
                }
            }
            return false;
        }
    }

    function showStartScreen() {
        gameState = 'START';
        startScreen.classList.remove('hidden');
        gameOverScreen.classList.add('hidden');
        scoreDisplay.classList.add('hidden');
    }

    function startGame(difficulty) {
        if (difficulty === 'easy') {
            currentPipeGap = 240; 
            currentSpawnRate = 110;
            obstacleSpawnRate = 220; 
        } else {
            currentPipeGap = 210; 
            currentSpawnRate = 95;
            obstacleSpawnRate = 130; 
        }

        bird = new Bird();
        pipes = [];
        obstacles = [];
        frameCount = 0;
        score = 0;
        gameState = 'PLAYING';
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        scoreDisplay.classList.remove('hidden');
        scoreDisplay.innerText = "0";
    }

    function endGame() {
        if (gameState === 'GAMEOVER') return;
        gameState = 'GAMEOVER';
        if (score > highScore) highScore = score;
        
        finalScoreTxt.innerText = `Score: ${score}`;
        bestScoreTxt.innerText = `Best: ${highScore}`;
        
        scoreDisplay.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
    }

    function drawBackground() {
        let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, "#4ec0ca");
        grad.addColorStop(1, "#dff6f5");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#73bf2e";
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
    }

    function gameLoop() {
        drawBackground();

        if (gameState === 'PLAYING') {
            frameCount++;
            
            // Pipe Spawning
            if (frameCount % currentSpawnRate === 0) {
                const lastPipeHeight = pipes.length > 0 ? pipes[pipes.length - 1].topHeight : null;
                pipes.push(new Pipe(lastPipeHeight));
            }

            // Obstacle (Fireball) Spawning
            if (frameCount % obstacleSpawnRate === 0) {
                obstacles.push(new Obstacle());
            }

            bird.update();
            bird.draw();

            // Update Pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].update();
                pipes[i].draw();

                if (pipes[i].collidesWith(bird)) {
                    endGame();
                }

                if (!pipes[i].passed && pipes[i].x + pipes[i].width < bird.x) {
                    pipes[i].passed = true;
                    score++;
                    scoreDisplay.innerText = score;
                }

                if (pipes[i].x + pipes[i].width < -50) {
                    pipes.splice(i, 1);
                }
            }

            // Update Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                obstacles[i].draw();

                if (obstacles[i].collidesWith(bird)) {
                    endGame();
                }

                if (obstacles[i].x < -50) {
                    obstacles.splice(i, 1);
                }
            }

        } else if (gameState === 'START') {
            const hover = Math.sin(Date.now() / 200) * 15;
            ctx.save();
            ctx.translate(0, hover);
            const tempBird = new Bird();
            tempBird.draw();
            ctx.restore();
        } else if (gameState === 'GAMEOVER') {
            pipes.forEach(p => p.draw());
            obstacles.forEach(o => o.draw());
            bird.draw();
        }

        requestAnimationFrame(gameLoop);
    }

    function handleInput(e) {
        if (e.code === 'Space' || e.type === 'mousedown' || e.type === 'touchstart') {
            if (gameState === 'PLAYING') {
                bird.jump();
            }
            if (e.type === 'touchstart' && e.target.tagName !== 'BUTTON') e.preventDefault();
        }
    }

    window.addEventListener('keydown', handleInput);
    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, { passive: false });

    gameLoop();
</script>

</body>
</html>
